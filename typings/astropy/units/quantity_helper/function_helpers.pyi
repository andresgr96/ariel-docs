from _typeshed import Incomplete
from astropy.units.core import dimensionless_unscaled as dimensionless_unscaled
from astropy.units.errors import UnitConversionError as UnitConversionError, UnitTypeError as UnitTypeError, UnitsError as UnitsError
from astropy.utils import isiterable as isiterable
from astropy.utils.compat import COPY_IF_NEEDED as COPY_IF_NEEDED, NUMPY_LT_1_24 as NUMPY_LT_1_24, NUMPY_LT_2_0 as NUMPY_LT_2_0, NUMPY_LT_2_1 as NUMPY_LT_2_1
from collections.abc import Generator

ARRAY_FUNCTION_ENABLED: Incomplete
SUBCLASS_SAFE_FUNCTIONS: Incomplete
FUNCTION_HELPERS: Incomplete
DISPATCHED_FUNCTIONS: Incomplete
SUPPORTED_NEP35_FUNCTIONS: Incomplete
UNSUPPORTED_FUNCTIONS: Incomplete
TBD_FUNCTIONS: Incomplete
IGNORED_FUNCTIONS: Incomplete

class FunctionAssigner:
    assignments: Incomplete
    def __init__(self, assignments) -> None: ...
    def __call__(self, f: Incomplete | None = None, helps: Incomplete | None = None, module=...):
        """Add a helper to a numpy function.

        Normally used as a decorator.

        If ``helps`` is given, it should be the numpy function helped (or an
        iterable of numpy functions helped).

        If ``helps`` is not given, it is assumed the function helped is the
        numpy function with the same name as the decorated function.
        """

function_helper: Incomplete
dispatched_function: Incomplete

def invariant_a_helper(a, *args, **kwargs): ...
def invariant_m_helper(m, *args, **kwargs): ...
def invariant_x_helper(x, *args, **kwargs): ...
def like_helper(a, *args, **kwargs): ...
def _quantity_out_as_array(out): ...
def nanvar(a, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, ddof: int = 0, keepdims=..., **kwargs): ...
def nanstd(a, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, ddof: int = 0, keepdims=..., **kwargs): ...
def sinc(x): ...
def unwrap(p, discont: Incomplete | None = None, axis: int = -1, *, period=...): ...
def argpartition(a, *args, **kwargs): ...
def full_like(a, fill_value, *args, **kwargs): ...
def putmask(a, mask, values): ...
def place(arr, mask, vals): ...
def copyto(dst, src, *args, **kwargs): ...
def nan_to_num(x, copy: bool = True, nan: float = 0.0, posinf: Incomplete | None = None, neginf: Incomplete | None = None): ...
def _as_quantity(a):
    """Convert argument to a Quantity (or raise NotImplementedError)."""
def _as_quantities(*args):
    """Convert arguments to Quantity (or raise NotImplentedError)."""
def _quantities2arrays(*args, unit_from_first: bool = False):
    """Convert to arrays in units of the first argument that has a unit.

    If unit_from_first, take the unit of the first argument regardless
    whether it actually defined a unit (e.g., dimensionless for arrays).
    """
def _iterable_helper(*args, out: Incomplete | None = None, **kwargs):
    """Convert arguments to Quantity, and treat possible 'out'."""
def concatenate(arrays, axis: int = 0, out: Incomplete | None = None, **kwargs): ...
def _block(arrays, max_depth, result_ndim, depth: int = 0): ...

UNIT_FROM_LIKE_ARG: Incomplete

def arange(*args, start: Incomplete | None = None, stop: Incomplete | None = None, step: Incomplete | None = None, dtype: Incomplete | None = None): ...
def arange_impl(*args, start: Incomplete | None = None, stop: Incomplete | None = None, step: Incomplete | None = None, dtype: Incomplete | None = None, **kwargs): ...
def creation_helper(shape, dtype: Incomplete | None = None, order: str = 'C'): ...
def full(shape, fill_value, dtype: Incomplete | None = None, order: str = 'C'): ...
def full_impl(shape, fill_value, *args, **kwargs): ...
def require(a, dtype: Incomplete | None = None, requirements: Incomplete | None = None): ...
def array(object, dtype: Incomplete | None = None, *, copy: bool = True, order: str = 'K', subok: bool = False, ndmin: int = 0): ...

asarray_impl_1_helps: Incomplete
asarray_impl_2_helps: Incomplete

def asarray_impl_1(a, dtype: Incomplete | None = None, order: Incomplete | None = None): ...
def asarray_impl_2(a, dtype: Incomplete | None = None, order: Incomplete | None = None, *, device: Incomplete | None = None, copy: Incomplete | None = None): ...
def aslayoutarray_helper(a, dtype: Incomplete | None = None): ...
def fromfunction(function, shape, *, dtype=..., **kwargs): ...
def generic_like_array_function_helper(*args, **kwargs): ...
def block(arrays): ...
def choose(a, choices, out: Incomplete | None = None, mode: str = 'raise'): ...
def select(condlist, choicelist, default: int = 0): ...
def piecewise(x, condlist, funclist, *args, **kw): ...
def append(arr, values, *args, **kwargs): ...
def insert(arr, obj, values, *args, **kwargs): ...
def pad(array, pad_width, mode: str = 'constant', **kwargs): ...
def where(condition, *args): ...
def quantile(a, q, *args, _q_unit=..., **kwargs): ...
def percentile(a, q, *args, **kwargs): ...
def nanmedian(a, axis: Incomplete | None = None, out: Incomplete | None = None, overwrite_input: bool = False, keepdims=...): ...
def count_nonzero(a, *args, **kwargs): ...
def close(a, b, rtol: float = 1e-05, atol: float = 1e-08, *args, **kwargs): ...
def array_equal(a1, a2, equal_nan: bool = False): ...
def array_equiv(a1, a2): ...
def dot_like(a, b, out: Incomplete | None = None): ...
def cross_like_a_b(a, b, *args, **kwargs): ...
def cross_like_a_v(a, v, *args, **kwargs): ...
def einsum(*operands, out: Incomplete | None = None, **kwargs): ...
def bincount(x, weights: Incomplete | None = None, minlength: int = 0): ...
def digitize(x, bins, *args, **kwargs): ...
def _check_bins(bins, unit): ...
def _check_range(range, unit): ...
def histogram_bin_edges(a, bins: int = 10, range: Incomplete | None = None, weights: Incomplete | None = None): ...
def histogram(a, bins: int = 10, range: Incomplete | None = None, density: Incomplete | None = None, weights: Incomplete | None = None): ...
def histogram2d(x, y, bins: int = 10, range: Incomplete | None = None, density: Incomplete | None = None, weights: Incomplete | None = None): ...
def histogramdd(sample, bins: int = 10, range: Incomplete | None = None, density: Incomplete | None = None, weights: Incomplete | None = None): ...
def histogram_pre_1_24(a, bins: int = 10, range: Incomplete | None = None, normed: Incomplete | None = None, weights: Incomplete | None = None, density: Incomplete | None = None): ...
def histogram2d_pre_1_24(x, y, bins: int = 10, range: Incomplete | None = None, normed: Incomplete | None = None, weights: Incomplete | None = None, density: Incomplete | None = None): ...
def histogramdd_pre_1_24(sample, bins: int = 10, range: Incomplete | None = None, normed: Incomplete | None = None, weights: Incomplete | None = None, density: Incomplete | None = None): ...
def diff(a, n: int = 1, axis: int = -1, prepend=..., append=...): ...
def gradient(f, *varargs, **kwargs): ...
def logspace(start, stop, *args, **kwargs): ...
def geomspace(start, stop, *args, **kwargs): ...
def interp(x, xp, fp, *args, **kwargs): ...
def unique(ar, return_index: bool = False, return_inverse: bool = False, return_counts: bool = False, axis: Incomplete | None = None, **kwargs): ...
def intersect1d(ar1, ar2, assume_unique: bool = False, return_indices: bool = False): ...
def twosetop(ar1, ar2, *args, **kwargs): ...
def isin(element, test_elements, *args, **kwargs): ...
def in1d(ar1, ar2, *args, **kwargs): ...
def apply_over_axes(func, a, axes): ...
def array_repr(arr, *args, **kwargs): ...
def array_str(a, *args, **kwargs): ...
def array2string(a, *args, **kwargs): ...
def diag(v, *args, **kwargs): ...
def svd(a, full_matrices: bool = True, compute_uv: bool = True, hermitian: bool = False): ...
def _interpret_tol(tol, unit): ...
def matrix_rank(A, tol: Incomplete | None = None, *args, **kwargs): ...
def inv(a, *args, **kwargs): ...
def pinv(a, rcond: float = 1e-15, *args, **kwargs): ...
def det(a): ...
def solve(a, b, *args, **kwargs): ...
def lstsq(a, b, rcond=...): ...
def norm(x, ord: Incomplete | None = None, *args, **kwargs): ...
def matrix_power(a, n): ...
def cholesky(a): ...
def qr(a, mode: str = 'reduced'): ...
def eig(a, *args, **kwargs): ...
def outer(x1, x2, /): ...
def structured_to_unstructured(arr, *args, **kwargs):
    """
    Convert a structured quantity to an unstructured one.
    This only works if all the units are compatible.

    """
def _build_structured_unit(dtype, unit):
    """Build structured unit from dtype.

    Parameters
    ----------
    dtype : `numpy.dtype`
    unit : `astropy.units.Unit`

    Returns
    -------
    `astropy.units.Unit` or tuple
    """
def unstructured_to_structured(arr, dtype: Incomplete | None = None, *args, **kwargs): ...
def _izip_units_flat(iterable) -> Generator[Incomplete, Incomplete]:
    """Returns an iterator of collapsing any nested unit structure.

    Parameters
    ----------
    iterable : Iterable[StructuredUnit | Unit] or StructuredUnit
        A structured unit or iterable thereof.

    Yields
    ------
    unit
    """
def merge_arrays(seqarrays, fill_value: int = -1, flatten: bool = False, usemask: bool = False, asrecarray: bool = False):
    """Merge structured Quantities field by field.

    Like :func:`numpy.lib.recfunctions.merge_arrays`. Note that ``usemask`` and
    ``asrecarray`` are not supported at this time and will raise a ValueError if
    not `False`.
    """
